#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ptrace.h>

extern "C" {
#include "read_maps.h"
}

int do_child()
{
	int status;
	char *argv[]={NULL};
	// char *envp[]={"/system/lib", NULL};

	// status = execlp("/system/bin/mediaserver", NULL);
	status = execve("/sbin/huawei_version", argv, NULL);
	// kill(getpid(), SIGSTOP);
	if (status == -1) {
		printf("error in child:%d\n", errno);
	} else {
		printf("good.\n");
	}
	sleep(100*1000);
	return 0;
}

/* Used for ignored arguments */
static pid_t ignored_pid = 0;
static void *ignored_ptr = NULL;

static void setup_inferior(const char *path, char *const argv[])
{
  ptrace(PTRACE_TRACEME, ignored_pid, ignored_ptr, ignored_ptr);
  // kill(getpid(), SIGSTOP);
  execv(path, argv);
}

static void *no_continue_signal = 0;

static void attach_to_inferior(pid_t pid)
{
	int signo = 0;
  while(1) {
    int	status;
    waitpid(pid, &status, 0);
    printf("attach_to_inferior\n");

    if (WIFSTOPPED(status)) {
      printf("Inferior stopped on SIGTRAP - continuing... %d\n", WSTOPSIG(status));
      signo = WSTOPSIG(status);
      if (WSTOPSIG(status) == SIGTRAP) {
      	signo = 0;
      	if(ptrace(PTRACE_CONT, pid, NULL, (void*)signo) == -1) {
      		printf("PTRACE_CONT failed:%d\n", errno);
      	}
      	sleep(5);
			char szbuf[1024];
			snprintf(szbuf, sizeof(szbuf), "/proc/%d/maps", pid);
			printf("szbuf:%s\n", szbuf);

			FILE *fin = fopen(szbuf, "r");
			char szline[1024];
			while (fgets(szline, sizeof(szline), fin) != NULL) {
				printf("%s\n", szline);
			}
			fseek(fin, 0L, SEEK_SET);
			struct proc_map *info = read_maps(fin, "/system/lib/libcamera_client.so");
			if (info != NULL) {
				printf("proc base:%d, lo:%d, hi:%d\n", info->base, info->lo, info->hi);
				free_maps(info);
			} else {
				printf("not found.\n");
			}

			// printf("free_maps\n");

      } else {
      	ptrace(PTRACE_CONT, pid, NULL, (void*)signo);
  	  }
  	  // ptrace (PTRACE_DETACH, pid, NULL, (void*)0);
    } else if (WIFEXITED(status)) {
      printf("Inferior exited - debugger terminating...\n");
      // exit(0);
    }
  }
  printf("attach_to_inferior done.\n");
}

int main(int argc, char* argv[])
{
	pid_t pid;
	int status, child_status;
	int exit_code;
	FILE *fin;

	switch(pid = fork()) {
		case 0:
		{
			/* child process */			
			printf("child.\n");
			// ptrace(PTRACE_TRACEME, 0, NULL, NULL);
			// do_child();
			char *argv[]={"/system/bin/mediaserver", NULL};
			setup_inferior("/system/bin/mediaserver", argv);
			exit_code = 5;			
			return exit_code;
		}
		case -1:
			exit_code = 1;
			return exit_code;
			break;
		default:
		{
			char szbuf[1024];
			snprintf(szbuf, sizeof(szbuf), "/proc/%d/maps", pid);
			printf("szbuf:%s\n", szbuf);

			attach_to_inferior(pid);

			waitpid(pid, &child_status, 0);
			FILE *fin = fopen(szbuf, "r");
			char szline[1024];
			while (fgets(szline, sizeof(szline), fin) != NULL) {
				printf("%s\n", szline);
			}
			fseek(fin, 0L, SEEK_SET);
			struct proc_map *info = read_maps(fin, "/system/lib/libcamera_client.so");
			if (info != NULL) {
				printf("proc base:%d, lo:%d, hi:%d\n", info->base, info->lo, info->hi);
			} else {
				printf("not found.\n");
			}
			free_maps(info);
			printf("free_maps\n");
			break;
		}
	}

	printf("parent, child:%d\n", pid);
	status = waitpid(pid, &child_status, WNOHANG);
	switch(status) {
		case -1:
			break;
		case 0:
			break;
		default:
			break;
			printf("child exit code: %d\n", child_status);
	}
	exit_code = 0;
	printf("done.\n");
	return exit_code;
}